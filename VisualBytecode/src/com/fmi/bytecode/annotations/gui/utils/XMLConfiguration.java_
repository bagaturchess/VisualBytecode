/*package utils;

public class XMLConfiguration {
    public XMLConfiguration() {
    }
}*/

package utils;

import java.io.ByteArrayInputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.io.StringWriter;

import java.net.URI;
import java.net.URISyntaxException;

import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.Properties;
import java.util.Vector;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.FactoryConfigurationError;
import javax.xml.parsers.ParserConfigurationException;


import org.apache.commons.lang.StringEscapeUtils;

import org.eclipse.emf.common.util.EList;
import org.eclipse.xsd.XSDComplexTypeDefinition;
import org.eclipse.xsd.XSDElementDeclaration;
import org.eclipse.xsd.XSDModelGroup;
import org.eclipse.xsd.XSDParticle;
import org.eclipse.xsd.XSDSchema;
import org.eclipse.xsd.XSDTypeDefinition;
import org.eclipse.xsd.impl.XSDElementDeclarationImpl;
import org.eclipse.xsd.util.XSDParser;

import org.jdom.adapters.CrimsonDOMAdapter;
import org.jdom.adapters.DOMAdapter;

import org.w3c.dom.Attr;
import org.w3c.dom.Comment;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.Text;

import org.xml.sax.SAXException;


/**
 * <p>
 * XML file based <code>Configuration</code>. This class provides two static
 * methods:<br>
 *  - <code>getConfigurationForString(String)</code>, which parses a valid XML
 *    String to XMLConfiguration;<br>
 *  - <code>getConfigurationForSchema(String)</code>, which builds Configuration
 *    tree, by parsing the supplied XML Schema (XSD) file
 *    
 * <p>
 * Each <code>XMLConfiguration</code> instance is backed-up by <code>org.w3c.dom.Document</code>.
 * All children of an <code>XMLConfiguration</code> obtained through {@ling #getChildren(String)}
 * method share the same <code>org.w3c.dom.Document</code>. If you wish to obtain
 * a <code>org.w3c.dom.Document</code>, specific for a certain <code>XMLConfiguration</code>,
 * you should use {@ling #getLocalDOM(String)} method.
 */
public class XMLConfiguration extends AbstractConfiguration implements Cloneable {
    /**
     * Header tag for saving XML Documents
     */
    public static final String XML_HEAD = "<?xml version='1.0' encoding='utf-8'?>";

    /**
     * String, used to indent tags on different levels, when printing the XML
     * Document
     */
    public static final String INDENT = "    ";

    // DOM adapters for generating XML Document of a specific implementation
    public static final String ORACLE_ADAPTER = "org.jdom.adapters.OracleV2DOMAdapter";
    public static final String CRIMSON_ADAPTER = "org.jdom.adapters.CrimsonDOMAdapter";
    public static final String JAXP_ADAPTER = "org.jdom.adapters.JAXPDOMAdapter";
    public static final String XERCES_ADAPTER = "org.jdom.adapters.XercesDOMAdapter";
    public static final String XML4J_ADAPTER = "org.jdom.adapters.XML4JDOMAdapter";

    public boolean updated = false;

    private Document doc = null;
    private Element root = null;
    private File output = null;

    private Configuration parent = null;

    /**
     * Default constructor. Creates an empty configuration object with root
     * element called "Configuration".
     * 
     * @throws ConfigurationException
     */
    public XMLConfiguration() throws ConfigurationException {
        DocumentBuilderFactory fac = DocumentBuilderFactory.newInstance();
        DocumentBuilder builder;
        try {
            builder = fac.newDocumentBuilder();
        } catch (ParserConfigurationException e) {
            e.printStackTrace();
            throw new ConfigurationException(e.getMessage(), e);
        }
        doc = builder.newDocument();
        root = doc.createElement("Configuration");
    }

    /**
     * Creates configuration object with the specified root element name. The
     * newly created <code>XMLConfiguration</code> is in the context
     * <b>parent</b> configuration, but should be explicitely appended to it by
     * invoking <code>appendChild(Configuration)</code>.
     * 
     * @param rootElement
     *          The name of the root element of the new Configuration
     * @param parent
     *          Parent Configuration, to which the newly created Configuration
     *          should be appended
     * @throws ConfigurationException
     */
    public XMLConfiguration(String rootElement, XMLConfiguration parent) 
    throws ConfigurationException {
        this.doc = parent.getDoc();
        this.root = doc.createElement(rootElement);
        this.parent = parent;
    }

    /**
     * Creates new <code>XMLConfiguration</code> from an input character stream. 
     * The stream should represent a valid XML Document.
     * 
     * @param in
     * 
     * @throws ConfigurationException
     */
    public XMLConfiguration(InputStream in) throws ConfigurationException {
        DocumentBuilderFactory fac = DocumentBuilderFactory.newInstance();
        DocumentBuilder builder;
        try {
            builder = fac.newDocumentBuilder();
            doc = builder.parse(in);            
        } catch (ParserConfigurationException e) {
            throw new ConfigurationException(e.getMessage(), e);
        } catch (SAXException e) {
            throw new ConfigurationException(e.getMessage(), e);
        } catch (IOException e) {
            throw new ConfigurationException(e.getMessage(), e);
        }
        root = doc.getDocumentElement();
    }

    /**
     * Creates new <code>XMLConfiguration</code> from the specified input file.
     * 
     * @param confFile
     *          Valid URI to an XML file
     *          
     * @throws ConfigurationException
     */
    public XMLConfiguration(String confFile) throws ConfigurationException {
        DocumentBuilderFactory fac = DocumentBuilderFactory.newInstance();
        DocumentBuilder builder;
        try {
            builder = fac.newDocumentBuilder();
            doc = builder.parse(confFile);
            
            output = new File(new URI(confFile));
        } catch (ParserConfigurationException e) {
            e.printStackTrace();
            throw new ConfigurationException(e.getMessage(), e);
        } catch (SAXException e) {
            e.printStackTrace();
            throw new ConfigurationException(e.getMessage(), e);
        } catch (IOException e) {
            e.printStackTrace();
            throw new ConfigurationException(e.getMessage(), e);
        } catch (URISyntaxException e) {
        }
        root = doc.getDocumentElement();
    }

    /**
     * Creates new <code>XMLConfiguration</code> for the specified <code>Element</code>,
     * with specified parent Configuration. The provided root <code>Element</code>
     * is imported into parent's <code>org.w3c.Document</code>.
     * 
     * @param root
     *      The element, which should become root Element in the new Configuration
     * @param parent
     *      Parent Configuration, to which this new Configuration will be 
     *      appended
     */
    public XMLConfiguration(Element root, XMLConfiguration parent) {
        this.doc = parent.getDoc();
        Node imported = doc.importNode(root, true);
        doc.appendChild(imported);
        this.root = (Element)imported;
        this.parent = parent;
    }
    
    /**
     * Creates new <code>XMLConfiguration</code> with specified <code>Document</code>, 
     * root <code>Element</code> and parent Configuration. If the supplied root
     * <code>Element</code> is not from tree of the supplied <code>Document</code>,
     * than it is imported into it.
     * 
     * @param doc
     * @param root
     * @param parent
     */
    public XMLConfiguration(Document doc, Element root, XMLConfiguration parent) {
        this.doc = doc;
        if (root.getOwnerDocument()==doc) {
            this.root = root;
        } else {
            Element imported = (Element)doc.importNode(root, true);
            doc.appendChild(imported);
            this.root = imported;
        }
        this.parent = parent;
    }    

    /**
     * Creates new <code>XMLConfiguration</code> from the supplied <code>org.w3c.Document</code>
     * 
     * @param doc
     */
    public XMLConfiguration(Document doc) {
        this.doc = doc;
        this.root = doc.getDocumentElement();
    }

    /**
     * Creates new <code>XMLConfiguration</code> from the supplied <code>org.w3c.Document</code>,
     * with the specified root element name
     * @param doc
     * @param rootName
     */
    public XMLConfiguration(Document doc, String rootName) {
        this.doc = doc;
        this.root = doc.createElement(rootName);
    }

    /**
     * Usually, a <code>Configuration</code> tree represents a single XML document.
     * You may have a number of <code>Configuration</code> object, exctracted
     * from the same XML source. This method returns <code>org.w3c.dom.Document</code>
     * representing the main XML source for all <code>Configuration</code>s.
     *
     * @return
     */
    public Document getDoc() {
        return doc;
    }

    /**
     * Genrates XML DOM structure, representing this exact configuration. Unlike
     * <code>getDoc()</code> method, this one returns isolated DOM tree, different
     * from the main XML source, used to generate this XMLConfiguration.
     *
     * @param domType
     *          The type of the parser wich should be used to create the XML Document.
     *          The possible values are Oracle, Crimson, JAXP, Xerces, XML4J
     * @return
     */
    public Document getLocalDOM(String domType) {
        Document result = doc;
        DOMAdapter adapter = null;
        try {
            if (domType.equalsIgnoreCase("oracle")) {
                adapter = (DOMAdapter)Class.forName(ORACLE_ADAPTER).newInstance();
            } else if (domType.equalsIgnoreCase("crimson")) {
                adapter = (DOMAdapter)Class.forName(CRIMSON_ADAPTER).newInstance();
            } else if (domType.equalsIgnoreCase("jaxp")) {
                adapter = (DOMAdapter)Class.forName(JAXP_ADAPTER).newInstance();
            } else if (domType.equalsIgnoreCase("xerces")) {
                adapter = (DOMAdapter)Class.forName(XERCES_ADAPTER).newInstance();
            } else if (domType.equalsIgnoreCase("xml4j")) {
                adapter = (DOMAdapter)Class.forName(XML4J_ADAPTER).newInstance();
            } else {
                adapter = new CrimsonDOMAdapter();
            }
        } catch (Exception ex) {
            adapter = new CrimsonDOMAdapter();
        }
        try {
            InputStream is = new ByteArrayInputStream(toString().trim().getBytes("UTF8"));
            result = adapter.getDocument(is, false);
        } catch (Exception ex) {
            ex.printStackTrace();
        }
        return result;
    }

    /**
     * Get child configurations of this configurations object
     *
     * @param key
     *            defines which named children to return. It may be null and in
     *            this case all children are returned
     * @return array with all Configurations conforming this key or array of
     *         size 0, if no children are found
     */
    public Configuration[] getChildren(String key) {
        Configuration[] result = null;
        NodeList children = root.getChildNodes();
        Vector els = new Vector(children.getLength());

        for (int i = 0; i < children.getLength(); i++) {
            Node n = children.item(i);
            if (n.getNodeType()==Node.ELEMENT_NODE) {
                if (key == null) {
                    els.add(n);
                } else {
                    if (n.getNodeName().equals(key))
                        els.add(n);
                }
            }
        }

        result = new Configuration[els.size()];
        for (int i = 0; i < els.size(); i++) {
            result[i] = new XMLConfiguration(doc, (Element)els.elementAt(i), this);
        }

        return result;
    }

    /**
     *
     * @return parent Configuration or <code>null</code>, if this is the root
     */
    public Configuration getParent() {
        return parent;
    }

    /**
     * Gets all properties and their values of this Configuration object
     * 
     * @return Hashtable, where the keys are the property names and values are
     *         the respecive values
     */
    public Hashtable getProperties() {
        Hashtable result = new Hashtable();
        NodeList children = root.getChildNodes();
        for (int i = 0; i < children.getLength(); i++) {
            Node n = children.item(i);
            if (n.getNodeType()==Node.ELEMENT_NODE) {
                String key = n.getNodeName();
                NodeList content = n.getChildNodes();
                String value = "";
                for (int j = 0; j < content.getLength(); j++) {
                    if (content.item(j).getNodeType()==Node.TEXT_NODE) {
                        value += ((Text)content.item(j)).getData();
                    }
                }
                result.put(key, value);
            }
        }
        return result;
    }

    /**
     *
     * @return this Configuration object's name (identifier)
     */
    public String getName() {
        return root.getTagName();
    }

    /**
     * Get value of specified Configuration property as String
     *
     * @param key
     *            named property to get. If key is null or empty string the
     *            method makes attempt to get the value of Configuration's root
     *            element
     * @return the value of the property or empty string if property with such
     *         name does not exists
     */
    public String getPropertyAsString(String key) {
        String result = "";

        if (key == null || key.equals("")) {
            NodeList children = root.getChildNodes();
            String text = "";
            for (int i = 0; i < children.getLength(); i++) {
                if (children.item(i).getNodeType()==Node.TEXT_NODE) {
                    text += ((Text)children.item(i)).getData();
                }
            }
            if (!text.equals("")) {
                result = text;
            }
        } else {
            NodeList els = root.getElementsByTagName(key);

            if (els.getLength() > 0) {
                Element parameter = (Element)els.item(0);
                NodeList children = parameter.getChildNodes();
                String text = "";
                for (int i = 0; i < children.getLength(); i++) {
                    if (children.item(i).getNodeType()==Node.TEXT_NODE) {
                        text += ((Text)children.item(i)).getData();
                    }
                }
                if (!text.equals("")) {
                    result = text;
                }
            }
        }
        return result.trim();
    }

    /**
     * Get value of specified Configuration property as String
     *
     * @param key
     *            name of the property to get
     * @param def
     *            default value for this property
     * @return the value of the property or <b>def</b> if property with such
     *         name does not exists
     */
    public String getPropertyAsString(String key, String def) {
        String result = getPropertyAsString(key);
        if (result == null || result.equals(""))
            result = def;
        return result;
    }

    /**
     * Get value of property attribute as String
     *
     * @param pKey
     *            name of the property
     * @param aKey
     *            name of the attribute
     * @return the value of the attribute or <b>null</b> if attribute with such
     *         name does not exists
     */
    public String getAttributeAsString(String pKey, String aKey) {
        String result = "";

        if (pKey.equals("")) {
            result = root.getAttribute(aKey);
        } else {

            NodeList els = root.getElementsByTagName(pKey);

            if (els.getLength() > 0) {
                Element parameter = (Element)els.item(0);
                result = parameter.getAttribute(aKey);
            }
        }
        return result.trim();
    }

    /**
     * Get value of property attribute as String
     *
     * @param pKey
     *            name of the property
     * @param aKey
     *            name of the attribute
     * @param def
     *            default value for this attribute
     * @return the value of the attribute or <b>def</b> if attribute with such
     *         name does not exists
     */
    public String getAttributeAsString(String pKey, String aKey, String def) {
        String result = getAttributeAsString(pKey, aKey);
        if (result == null || result.equals(""))
            result = def;
        return result;
    }

    /**
     * 
     * @param pKey
     * @return
     * @see Configuration#getAttributes(String)
     */
    public Hashtable getAttributes(String pKey) {
        Hashtable result = new Hashtable();
        Node element = root;
        if (pKey != null && !pKey.equals("")) {
            NodeList els = root.getElementsByTagName(pKey);
            if (els.getLength() > 0) {
                element = els.item(0);
            } else {
                element = null;
            }
        }
        if (element != null) {
            NamedNodeMap attributes = element.getAttributes();
            for (int i = 0; i < attributes.getLength(); i++) {
                Attr a = (Attr)attributes.item(i);
                result.put(a.getName(), a.getValue());
            }
        }

        return result;
    }

    /**
     * 
     * @return the root <code>org.w3c.Element</code> of the DOM tree
     */
    public Element getRootElement() {
        return root;
    }

    /**
     * 
     * @param child
     * @see Configuration#appendChild(Configuration)
     */
    public void appendChild(Configuration child) {
        if (child instanceof XMLConfiguration && 
            ((XMLConfiguration)child).getDoc() == doc) {
            root.appendChild(((XMLConfiguration)child).getRootElement());
        } else {
            try {
                appendChild(this, child);
            } catch (ConfigurationException ex) {
            }
        }
        setUpdated(true);
    }

    private void appendChild(XMLConfiguration parent, Configuration child) 
    throws ConfigurationException {
        String name = child.getName();
        Hashtable attributes = child.getAttributes(null);
        // Construct new XMLConfiguration, which will have the same name, 
        // attributes and children as the child Configuration, but will be
        // in the context of this XMLConfiguration's Document
        XMLConfiguration xmlChild = new XMLConfiguration(name, parent);
        for (Enumeration e = attributes.keys(); e.hasMoreElements(); ) {
            String key = (String)e.nextElement();
            String value = (String)attributes.get(key);
            xmlChild.setAttribute("", key, formatValue(value));
        }
        xmlChild.setProperty("", formatValue(child.getPropertyAsString("", "")));

        Configuration[] cChildren = child.getChildren(null);
        for (int i = 0; i < cChildren.length; i++) {
            appendChild(xmlChild, cChildren[i]);
        }
        parent.appendChild(xmlChild);
    }

    private String formatValue(String v) {
        return StringEscapeUtils.escapeXml(StringEscapeUtils.unescapeXml(v));
    }

    /**
     * 
     * @param child
     * @see Configuration#removeChild(Configuration)
     */
    public void removeChild(Configuration child) {
        root.removeChild(((XMLConfiguration)child).getRootElement());
        setUpdated(true);
    }

    /**
     * 
     * @param childName
     * @see Configuration#removeChildren(String)
     */
    public void removeChildren(String childName) {
        NodeList nodes = root.getElementsByTagName(childName);
        for (int i = 0; i < nodes.getLength(); i++) {
            root.removeChild(nodes.item(i));
        }
        setUpdated(true);
    }
    
    /**
     * Removes child Configuration at the specified position
     * 
     * @param pos
     *          Position (0-based index) of the child to be removed
     */
    public void removeChild(int pos){
        Node childToRemove = this.getRootElement().getChildNodes().item(pos);
        this.getRootElement().removeChild(childToRemove);
    }

    /**
     * Replaces this <code>Configuration</code> with the supplied <code>Configuration</code>.
     * If this <code>Configuration</code> is the root of the tree (has no parent),
     * nothing is done.
     * 
     * @param newChild
     */
    public void replaceWith(Configuration newChild) {
        Node parent = this.root.getParentNode();
        if (parent!=null) {
            Element newNode = ((XMLConfiguration)newChild).getRootElement();
            parent.replaceChild(newNode, this.root);
            setUpdated(true);
        }
    }
    
    /**
     * Replaces child <code>Configuration</code> at the specified position with
     * the new <code>Configuration</code>. If there is no child element at the 
     * specified position, than nothing is done.
     * 
     * @param pos
     *          Position (0-based index) of the child to be replaced
     * @param newChild
     *          The replacement
     */
    public void replaceChild(int pos, Configuration newChild){
        try {
            Node child = this.getRootElement().getChildNodes().item(pos);
            this.getRootElement().replaceChild(((XMLConfiguration)newChild).getRootElement(), child);
            setUpdated(true);
        } catch (NullPointerException ex) {
            // NullPointerException is thrown, if the supplied position is not valid
        }
    }

    /**
     * 
     * @param key
     *          The property identifier
     * @param value
     *          The new value
     */
    public void setProperty(String key, String value) {
        NodeList els = root.getElementsByTagName(key);

        Element parameter;
        if (key.equals("")) {
            parameter = root;
        } else if (els.getLength() > 0) {
            parameter = (Element)els.item(0);
        } else {
            parameter = doc.createElement(key);
            root.appendChild(parameter);
        }

        // Remove current node values
        NodeList children = parameter.getChildNodes();
        for (int i = 0; i < children.getLength(); i++) {
            if (children.item(i).getNodeType()==Node.TEXT_NODE) {
                parameter.removeChild(children.item(i));
            }
        }

        if (value != null && !value.equals("")) {
            Text txt = doc.createTextNode(value);
            parameter.appendChild(txt);
        }
        setUpdated(true);
    }

    public void setProperty(String key, long value) {
        setProperty(key, String.valueOf(value));
    }

    public void setProperty(String key, double value) {
        setProperty(key, String.valueOf(value));
    }

    public void setProperty(String key, boolean value) {
        setProperty(key, String.valueOf(value));
    }

    /**
     * 
     * @param pKey
     *          Identifier of the property to which belongs this attribute
     * @param aKey
     *          Identifier of the attribute
     * @param value
     *          The new value
     */
    public void setAttribute(String pKey, String aKey, String value) {
        NodeList els = root.getElementsByTagName(pKey);

        if (els.getLength() > 0) {
            Element parameter = (Element)els.item(0);
            parameter.setAttribute(aKey, value);
        } else if (pKey.equals("")) {
            root.setAttribute(aKey, value);
        }
        setUpdated(true);
    }

    public void setAttribute(String pKey, String aKey, long value) {
        setAttribute(pKey, aKey, String.valueOf(value));
    }

    public void setAttribute(String pKey, String aKey, double value) {
        setAttribute(pKey, aKey, String.valueOf(value));
    }

    public void setAttribute(String pKey, String aKey, boolean value) {
        setAttribute(pKey, aKey, String.valueOf(value));
    }

    /**
     * <p>
     * Saves the configuration into an XML file. The output file is set through
     * {@link #setOutputFile(File)} method. If this <code>XMLConfiguration</code>
     * is created through {@link #XMLConfiguration(String)} constructor, than the 
     * output file by default is the source file.
     * 
     * <p>
     * The Configuration is saved only if the <code>updated</code> flag is set
     * to true. This happens implicitely when some of the setter or 
     * <code>appendChild</code> methods is called; or expicitely by 
     * {@link #setUpdated(boolean)} method.
     * 
     * @throws ConfigurationException
     */
    public void save() throws ConfigurationException {
        if (updated) {
            if (output == null)
                throw new ConfigurationException("Output file not specified.");
            if (!output.exists()) {
                File homeDir = output.getParentFile();
                homeDir.mkdirs();
            }
            String xml = XML_HEAD + "\n" + toString();
            DataOutputStream dos = null;
            try {
                byte[] buff = xml.getBytes("windows-1251");

                dos = new DataOutputStream(new FileOutputStream(output));
                dos.write(buff);
            } catch (IOException ex) {
                ex.printStackTrace();
                throw new ConfigurationException(ex.getMessage(), ex);
            } finally {
                try {
                    dos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                    throw new ConfigurationException(e.getMessage(), e);
                }
            }
        }
    }

    public String toString() {
        String result = "";
        try {
            StringWriter sw = new StringWriter();
            PrintWriter out = new PrintWriter(sw);
            printElement(root, out, 0);
            result = sw.toString();
        } catch (IOException e) {
        }
        return result.trim();
    }
    
    /**
     * Converts this XMLConfiguration to String by prefixing its elements and 
     * attributes with the specified Namespace prefix.
     * 
     * @param nsPrefix
     * @return
     */
    public String toStringNS(String nsPrefix, String uri) {
        String result = "";
        try {
            StringWriter sw = new StringWriter();
            PrintWriter out = new PrintWriter(sw);
            printElement(nsPrefix, uri, root, out, 0);
            result = sw.toString();
        } catch (IOException e) {
        }
        return result.trim();
    }

    /**
     * Sets the <code>updated</code> flag.
     * 
     * @param up
     * 
     * @see #save()
     */
    public void setUpdated(boolean up) {
        this.updated = up;
        if (parent!=null) {
            ((XMLConfiguration)parent).setUpdated(true);
        }
    }

    /**
     * Sets explicitely the output file, to which the Configuration should be
     * saved.
     * 
     * @param output
     * 
     * @see #save()
     */
    public void setOutputFile(File output) {
        this.output = output;
    }

    /**
     * Construct XMLConfiguration object for a String, containing XML text. The
     * <code>xml</code> parameter should contain valid, well-formed XML.
     *
     * @param xml
     *        The XML String
     * @return
     *        The new XMLConfiguration, if the supplied parameter is parsed
     *        successfully, or an empty XMLConfiguration if it's not
     */
    public static XMLConfiguration getConfigurationForString(String xml) {
        XMLConfiguration result = null;
        try {
            if (xml != null && xml.trim().startsWith("<")) {
                result = new XMLConfiguration(new ByteArrayInputStream(xml.trim().getBytes("UTF8")));
            } else {
                result = new XMLConfiguration();
            }
        } catch (Exception e) {
            e.printStackTrace();
            try {
                result = new XMLConfiguration();
            } catch (Exception ex) {
            }
        }
        return result;
    }

    /**
     * Parses an XSD Schema file and builds XMLConfiguration tree from it.
     * The tree contains no data - it is just reflection of schema structure
     *
     * @param schemaFile
     *             location of XSD file
     * @return
     *
     */
    public static XMLConfiguration getConfigurationForSchema(String schemaFile) throws ConfigurationException {
        XMLConfiguration result = null;
        // Hack for a problem in Oracle's parser
        String oldProvider = 
            System.getProperty("javax.xml.parsers.DocumentBuilderFactory");
        System.setProperty("javax.xml.parsers.DocumentBuilderFactory", 
                           "org.apache.crimson.jaxp.DocumentBuilderFactoryImpl");
        XSDParser p = new XSDParser(null);
        try {
            p.parse(schemaFile);
        } catch (FactoryConfigurationError ferr) {
            // Catch the error if the specified factory provider can not be found,
            // and use the default provider
            if (oldProvider != null) {
                System.setProperty("javax.xml.parsers.DocumentBuilderFactory", 
                                   oldProvider);
            } else {
                Properties sys = System.getProperties();
                sys.remove("javax.xml.parsers.DocumentBuilderFactory");
                System.setProperties(sys);
            }
            p.parse(schemaFile);
        }

        try {
            XSDSchema schema = p.getSchema();
            EList contents = schema.getElementDeclarations();
            Iterator i = contents.iterator();
            result = XMLConfiguration.getConfigurationForString("<XSDParse/>");
            while (i.hasNext()) {
                XSDElementDeclaration ed = (XSDElementDeclaration)i.next();
                buildXMLTree(schema, result, ed);
            }
        } catch (ConfigurationException ce) {
            throw ce;
        } catch (Exception ex) {
            throw new ConfigurationException("Parsing the schema file failed", 
                                             ex);
        }
        // Restore the initial XML Parser provider
        if (oldProvider != null) {
            System.setProperty("javax.xml.parsers.DocumentBuilderFactory", 
                               oldProvider);
        } else {
            Properties sys = System.getProperties();
            sys.remove("javax.xml.parsers.DocumentBuilderFactory");
            System.setProperties(sys);
        }
        return result;
    }

    /**
     * Helper method, which recursively builds the tree for an XSD element
     *
     * @param schema
     *          the original schema object
     * @param parent
     *          parent <code>XMLConfiguration</code> to which should be appended the next
     *          element
     * @param ed
     *          <code>XSDElementDeclaration</code> which has to be parsed and transformed to
     *          <code>XMLConfiguration</code>
     * @throws ConfigurationException
     */
    private static void buildXMLTree(XSDSchema schema, XMLConfiguration parent, 
                                     XSDElementDeclaration ed) throws ConfigurationException {
        boolean mandatory = isSchemaElementMandatory(ed);
        // If the element has not assigned name ("name" attribute), we will try 
        // to resolve it by reference ("ref" attribute)
        if (ed.getName() == null) {
            String resolvedName = ed.getResolvedElementDeclaration().getName();
            ed = findSchemaElement(schema, resolvedName);
        }

        XMLConfiguration edConf = new XMLConfiguration(ed.getName(), parent);
        parent.appendChild(edConf);

        XSDTypeDefinition initialType = ed.getTypeDefinition();
        if (initialType != null) {
            String typeName = initialType.getName();

            // The initial type definition obtained through ed.getTypeDefinition()
            // does not always contain all type attributes. That's why we have 
            // to performe custome type lookup based on type's name in the schema 
            XSDTypeDefinition td = findSchemaType(schema, typeName);
            if (td instanceof XSDComplexTypeDefinition) {
                XSDParticle particle = 
                    (XSDParticle)((XSDComplexTypeDefinition)td).getContent();
                mandatory = mandatory | (particle.getMinOccurs() > 0);
                XSDModelGroup mg = (XSDModelGroup)particle.getContent();
                EList contents = mg.getContents();
                Iterator i = contents.iterator();
                while (i.hasNext()) {
                    XSDParticle e = (XSDParticle)i.next();
                    XSDElementDeclaration el = 
                        XSDElementDeclarationImpl.createElementDeclaration(e.getElement());
                    buildXMLTree(schema, edConf, el);
                }
            }
        }
        //edConf.setAttribute("", "mandatory", mandatory);
    }

    /**
     * Helper method which finds Schema type by its name
     *
     * @param schema
     * @param name
     * @return
     */
    private static XSDTypeDefinition findSchemaType(XSDSchema schema, 
                                                    String name) {
        XSDTypeDefinition result = null;
        Iterator t = schema.getTypeDefinitions().iterator();
        while (t.hasNext()) {
            XSDTypeDefinition type = (XSDTypeDefinition)t.next();
            if (type.getName().equals(name)) {
                result = type;
                break;
            }
        }
        return result;
    }

    /**
     * Helper method which finds Schema element by its name
     *
     * @param schema
     * @param name
     * @return
     */
    private static XSDElementDeclaration findSchemaElement(XSDSchema schema, 
                                                           String name) {
        XSDElementDeclaration result = null;
        EList contents = schema.getElementDeclarations();
        Iterator i = contents.iterator();
        while (i.hasNext()) {
            XSDElementDeclaration ed = (XSDElementDeclaration)i.next();
            if (ed.getName().equals(name)) {
                result = ed;
                break;
            }
        }
        return result;
    }

    /**
     * Helper method for determining if a schema element is mandatory
     *
     * @param se
     * @return
     */
    private static boolean isSchemaElementMandatory(XSDElementDeclaration se) {
        int minOccurs = 1;
        try {
            XMLConfiguration e = 
                new XMLConfiguration(se.getElement(), new XMLConfiguration());
            minOccurs = e.getAttributeAsInt("", "minOccurs", 1);
        } catch (Exception ex) {
        }
        return (minOccurs > 0);
    }

    private void printElement(Element e, PrintWriter out, 
                              int level) throws IOException {
        printElement(null, null, e, out, level);
        /*
        // Begin on new line
        out.println();

        // Print indent
        for (int i = 0; i < level; i++) {
            out.print(INDENT);
        }

        // Print tag open
        out.print("<" + e.getTagName());

        NamedNodeMap attributes = e.getAttributes();
        for (int i = 0; i < attributes.getLength(); i++) {
            out.print(" " + attributes.item(i).getNodeName() + "=\"" + 
                      formatValue(attributes.item(i).getNodeValue()) + "\"");
        }

        NodeList childNodes = e.getChildNodes();

        // Close opening tag
        if (childNodes.getLength() == 0) {
            out.print("/>");
        } else {
            out.print(">");
            // Print child nodes
            for (int i = 0; i < childNodes.getLength(); i++) {
                if (childNodes.item(i).getNodeType()==Node.ELEMENT_NODE) {
                    printElement((Element)childNodes.item(i), out, level + 1);
                } else if (childNodes.item(i).getNodeType()==Node.COMMENT_NODE){
                    out.println("\n");
                    // Print indent
                    for (int j=0; j < level+1; j++) {
                        out.print(INDENT);
                    }
                    out.print(
                        "<!--"+((Comment)childNodes.item(i)).getData()+"-->"
                    );
                } else {
                    String txt = ((Text)childNodes.item(i)).getData();
                    if (txt != null && !txt.trim().equals("")) {
                        if (hasChildElements(e)) {
                            out.println();
                            for (int j = 0; j < level + 1; j++)
                                out.print(INDENT);
                        }
                        out.print(formatValue(txt));
                    }
                }
            }
            if (hasChildElements(e)) {
                out.println();
                // Print indent
                for (int i = 0; i < level; i++)
                    out.print(INDENT);
            }

            // Print tag close
            out.print("</" + e.getTagName() + ">");
        }
        */
    }
    
    private void printElement(String nsPrefix, String uri, Element e, PrintWriter out, 
                              int level) throws IOException {
        String prefix = (nsPrefix==null) ? "" : nsPrefix+":";
        String suffix = (nsPrefix==null) ? "" : ":"+nsPrefix;
        
        // Begin on new line
        out.println();

        // Print indent
        for (int i = 0; i < level; i++) {
            out.print(INDENT);
        }

        // Print tag open
        out.print("<" + prefix + e.getTagName());

        boolean nsAttribute = false;
        NamedNodeMap attributes = e.getAttributes();
        for (int i = 0; i < attributes.getLength(); i++) {
            String aName = attributes.item(i).getNodeName();
            out.print(" " + prefix + aName + "=\"" + 
                      formatValue(attributes.item(i).getNodeValue()) + "\"");
            if (aName.equals("xmlns"+suffix)) {
                nsAttribute = true;
            }
        }
        if (level==0 && uri!=null && !nsAttribute) {
            out.print(" xmlns"+suffix + "=\"" + uri + "\"");
        }

        NodeList childNodes = e.getChildNodes();

        // Close opening tag
        if (childNodes.getLength() == 0) {
            out.print("/>");
        } else {
            out.print(">");
            // Print child nodes
            for (int i = 0; i < childNodes.getLength(); i++) {
                if (childNodes.item(i).getNodeType()==Node.ELEMENT_NODE) {
                    printElement(nsPrefix, uri, (Element)childNodes.item(i), out, level + 1);
                } else if (childNodes.item(i).getNodeType()==Node.COMMENT_NODE){
                    out.println("\n");
                    // Print indent
                    for (int j=0; j < level+1; j++) {
                        out.print(INDENT);
                    }
                    out.print(
                        "<!--"+((Comment)childNodes.item(i)).getData()+"-->"
                    );
                } else {
                    String txt = ((Text)childNodes.item(i)).getData();
                    if (txt != null && !txt.trim().equals("")) {
                        if (hasChildElements(e)) {
                            out.println();
                            for (int j = 0; j < level + 1; j++)
                                out.print(INDENT);
                        }
                        out.print(formatValue(txt));
                    }
                }
            }
            if (hasChildElements(e)) {
                out.println();
                // Print indent
                for (int i = 0; i < level; i++)
                    out.print(INDENT);
            }

            // Print tag close
            out.print("</" + prefix + e.getTagName() + ">");
        }
    }

    private boolean hasChildElements(Element e) {
        NodeList childNodes = e.getChildNodes();
        for (int i = 0; i < childNodes.getLength(); i++) {
            if (childNodes.item(i).getNodeType()==Node.ELEMENT_NODE) {
                return true;
            }
        }
        return false;
    }
    
    /**
     * Tries to retrieve the namespace prefix for this Configuration's root
     * element. If the prefix is <code>null</code>, tries to find the namespace
     * URI attribute of the root element (i.e., attrinute which name starts with "xmlns:") 
     * and returns the part after the semicolon.
     * 
     * @return
     */
    public String getNamespacePrefix() {
        String result = root.getPrefix();
        if (result==null) {
            Enumeration attNames = getAttributes(null).keys();
            while(attNames.hasMoreElements()) {
                String name = (String)attNames.nextElement();
                if (name.startsWith("xmlns:")) {
                    result = name.substring(6);
                    break;
                }
            }
        }
        return result;
    }

    /**
     * Implements {@link Cloneable#clone} method.
     *
     * @see     Object#clone
     */
    public Object clone() throws CloneNotSupportedException {
        return  XMLConfiguration.getConfigurationForString(this.toString());
    }
}


